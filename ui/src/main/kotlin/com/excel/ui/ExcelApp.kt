package com.excel.ui

import com.excel.ui.core.Dispatchers
import com.excel.ui.viewmodel.ExcelViewModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject
import java.awt.Color
import java.awt.Component
import java.awt.event.WindowAdapter
import java.awt.event.WindowEvent
import javax.swing.BorderFactory
import javax.swing.DefaultListCellRenderer
import javax.swing.JFrame
import javax.swing.JList
import javax.swing.JScrollPane
import javax.swing.JTable
import javax.swing.ListSelectionModel
import javax.swing.table.TableColumnModel

class ExcelApp : JFrame(), KoinComponent {

    private val viewModel by inject<ExcelViewModel>()
    private val uiScope = CoroutineScope(SupervisorJob() + Dispatchers.Swing)

    init {
        val tableModel = CellObservingTableModel(uiScope, viewModel)

        val table = JTable(tableModel).apply {
            autoResizeMode = JTable.AUTO_RESIZE_OFF
            rowHeight = 32
            columnModel.setPreferredWidth(128)

            setShowGrid(true)
            gridColor = Color.LIGHT_GRAY

            setDefaultRenderer(Any::class.java, ResultCellRenderer())
            setDefaultEditor(Any::class.java, ExpressionCellEditor())
        }
        title = "Excel"
        contentPane.add(addRowHeaderWithSelection(table))
        setSize(2000, 1000)
        defaultCloseOperation = EXIT_ON_CLOSE
        isVisible = true

        addWindowListener(object : WindowAdapter() {
            override fun windowClosing(event: WindowEvent) {
                viewModel.onClear()
                uiScope.cancel()
            }
        })
    }

    private fun TableColumnModel.setPreferredWidth(width: Int) {
        repeat(columnCount) { columnIndex ->
            getColumn(columnIndex).preferredWidth = width
        }
    }

    /**
     * This function was generated by ChatGPT
     */
    private fun addRowHeaderWithSelection(table: JTable): JScrollPane {
        val rowHeader = JList<String>().apply {
            fixedCellWidth = 64
            fixedCellHeight = table.rowHeight
            selectionMode = ListSelectionModel.SINGLE_SELECTION
            background = Color(245, 245, 245)
            border = BorderFactory.createMatteBorder(0, 0, 0, 1, Color.LIGHT_GRAY)
        }
        rowHeader.cellRenderer = object : DefaultListCellRenderer() {
            override fun getListCellRendererComponent(
                list: JList<*>,
                value: Any?,
                index: Int,
                isSelected: Boolean,
                cellHasFocus: Boolean
            ): Component {
                val component = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus)
                horizontalAlignment = CENTER
                background = if (index == table.selectedRow) {
                    Color(200, 220, 255)
                } else {
                    list.background
                }
                foreground = if (index == table.selectedRow) {
                    Color.BLACK
                } else {
                    Color.DARK_GRAY
                }
                return component
            }
        }
        val updateNumbers = {
            val numbers = (1..table.rowCount).map(Int::toString)
            rowHeader.setListData(numbers.toTypedArray())
        }
        updateNumbers()
        table.model.addTableModelListener { updateNumbers() }

        table.selectionModel.addListSelectionListener { event ->
            rowHeader.repaint()
            if (event.valueIsAdjusting) {
                return@addListSelectionListener
            }
            val selected = table.selectedRow
            if (selected >= 0) {
                rowHeader.ensureIndexIsVisible(selected)
            }
        }
        return JScrollPane(table).apply {
            setRowHeaderView(rowHeader)
        }
    }
}
